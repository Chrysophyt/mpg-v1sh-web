import Head from 'next/head'
import Image from 'next/image'
import styles from '../styles/Home.module.css'

import * as ort from 'onnxruntime-web';
import { Tensor } from 'onnxruntime-web';
import { useState } from 'react'

const img_h = 300;
const img_w = 500;
const line_mul = 3;

function drawLine(ctx, strength, orient, radius, start_point, end_point){
  if(strength==0){
    return
  }
    const mid_point_x = ((start_point[0]+end_point[0])/2)
    const mid_point_y = ((start_point[1]+end_point[1])/2)

    const new_point1_x = (mid_point_x + radius * Math.cos(orient))
    const new_point1_y = (mid_point_y - radius * Math.sin(orient)) 

    const new_point2_x = (mid_point_x + radius * Math.cos(orient+Math.PI))
    const new_point2_y = (mid_point_y - radius * Math.sin(orient+Math.PI))


    ctx.beginPath()
    ctx.moveTo(Math.round(new_point1_x), Math.round(new_point1_y))
    ctx.lineTo(Math.round(new_point2_x), Math.round(new_point2_y))
    ctx.lineWidth = strength*line_mul
    // ctx.strokeStyle = '#000000'
    ctx.stroke()
}

function drawHypercolumns(canvas, hypercolumns, height, width, pixelSize){
  const K=12
  var pixelPad = 5
  var pixelRadius = pixelSize//2

  canvas.height = height * (pixelSize+2*pixelPad)
  canvas.width = width * (pixelSize+2*pixelPad)

  var ctx = canvas.getContext('2d');

  var orientations = new Array()
  for (let k=0; k<K; k++){
    orientations.push((Math.PI*k/K) - (Math.PI/2))
  }
  
  for (let k=0; k<K; k++){
    for (let h=0; h<height; h++){
      for (let w=0; w<width; w++){
        drawLine(ctx, hypercolumns[(k*height*width)+h*width+w], orientations[k], pixelRadius, 
          [w * (pixelSize + 2*pixelPad), h * (pixelSize + 2*pixelPad)], 
          [(w+1)*(pixelSize + 2*pixelPad), (h+1) * (pixelSize + 2*pixelPad)])
      }
    }
  }
  

}  


export default function Home() {
  const [img, setImg] = useState()
  const [canvasState, setCanvas] = useState()


  const inputData = async (event) => {
    event.preventDefault();
    const imageFile = document.getElementById('image').files[0]
    if(imageFile==null){
      return
    }
    // show canvas
    await setCanvas(1)
    var hcanvas = document.getElementById("myCanvas");

    // resize to designated res 300x500
    const canvas = document.createElement('canvas')
    const ctx = canvas.getContext('2d')
    canvas.width = img_w
    canvas.height = img_h
    var img = await createImageBitmap(imageFile);
    // scale & draw the image onto the canvas
    ctx.drawImage(img, 0, 0, img_w, img_h)
    // Get the binary (aka blob)
    const blob = await new Promise(rs => canvas.toBlob(rs, 1))
    const resizedFile = new File([blob], imageFile.name, imageFile)

    //set image
    setImg(URL.createObjectURL(resizedFile));

    //to float32
    const imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    const data = imgData.data
    console.log(imgData)

    const float32Data = new Float32Array(canvas.width*canvas.height)
    var data_iter = 0
    for(let i = 0; i < data.length; i += 4) {
      float32Data[data_iter] = (data[i]*0.299)/255.0 + (data[i+1]*0.587)/255.0 + (data[i+2]*0.114)/255.0
      data_iter +=1
    }
    console.log(float32Data)
    //const transposedData = rArray.concat(gArray).concat(bArray);

    const inputTensor = new Tensor("float32", float32Data, [300, 500]);

    console.log(inputTensor)
    //const inputTensor = new Tensor("float32", float32Data, [canvas.width, canvas.height]);

  
    const session = await ort.InferenceSession
                          .create('/GTH_.onnx',
                          { executionProviders: ['webgl'], graphOptimizationLevel: 'all' });
    console.log('Inference session created');

    const start = new Date();
    //const feeds: Record<string, ort.Tensor> = {};
    const feeds = {};
    feeds[session.inputNames[0]] = inputTensor
    console.log(feeds)
    var outputData  = await session.run(feeds);
    var outputData  = outputData[session.outputNames[0]]

    const end = new Date();
    const inferenceTime = (end.getTime() - start.getTime())/1000;

    console.log(inferenceTime)
    console.log(outputData)

    console.log(outputData.dims)
    
    
    await drawHypercolumns(hcanvas, outputData.data, 56, 96, 10)


  }



  return (
    <div className={styles.container}>
        <Head>
        <title>Contour Model | MPI for Biological Cybernetics</title>
        <meta name="description" content="Generated by create next app" />
        <link rel="icon" href="/favicon.ico" />
        </Head>

      <main className={styles.main}>
        <h2 className={styles.description} >
          A Neural Model of Contour Integration in the Primary Visual Cortex
        </h2>

      <div className={styles.grid}>
        <a href="https://nextjs.org/docs"  className={styles.card}>
        <h3>Documentation &rarr;</h3>
            <p>This is web implementation of paper.</p>
        </a>

        <div className={styles.card}>
          <h3>Input image</h3>

          <form onSubmit={inputData}>
            <label form="inputData">Input Image Data to Load:</label><br></br>
            <input type="file" id="image" />
            <button type="submit">Compute</button>
          </form>

          
          <div className="images" >
          {img && <Image 
          src={img} 
          alt="" 
          width={img_w}
          height={img_h}    
          />}
          </div>
        </div>

        {canvasState && <div className={styles.cardLarge}>
          <h3>Input Hypercolumns</h3>
          <canvas className={styles.canvas}
          id="myCanvas" 
          width="500" 
          height="300"/>
        </div>}

      </div>
      </main>

      <footer className={styles.footer}>
        <div>
          Computation and Cognition TÃ¼bingen Summer 2022
        </div>

        <a
          href="https://www.kyb.tuebingen.mpg.de/"
          target="_blank"
          rel="noopener noreferrer"
        >
        <Image src="/kybmpg.svg" height={150} width={400} />
        </a>

      </footer>
    </div>
  )
}

